[La version fran√ßaise suit.](#---------------------------------------------------------------------)

## Documentation

### Table of Contents

- [Next.JS and Server Side Rendering](#nextjs-and-server-side-rendering)
- [Styling the App](#styling-the-app)
- [AirTable](/doc/en/AIRTABLE.md)
- [Heroku](#using-heroku)
- [CircleCI](#using-circleci)
- [Test Driven Development](#test-driven-development)
- [BrowserStack](#using-browserstack)
- [Deployment](#deployment)
- [Translations](#translations)
- [Snyk](#using-snyk)
- [Testing](#testing)
- [Code Documentation](#code-documentation)
- [Contributing to GitHub repo](#contributing-to-github-repo)
- [Pair Programming](#pair-programming)
- [Deployment notifications](#deployment-notifications)

### Next.JS and Server Side Rendering

#### What is it?

[Next.JS](https://github.com/zeit/next.js/ "Next.JS") is a javascript framework for server-rendered React applications.

#### Why are we using it?

The rational behind choosing Next.JS stems from the following criteria:

- Use of both Javascript on the front-end and back-end
- Ability to render pages completely in HTML and CSS on the server
- Robust developer support and extensive third party ecosystem

To provide the most elegant and modern user experience, [ReactJS](https://reactjs.org/ "ReactJS") was chosen as the primary front-end framework. Traditionally, ReactJS based applications are built as two distinct services, one server side, and one client side, with individual code bases and often in different programming languages. When a user makes a request against an application with such an architecture, they usually load a bundled Javascript file, pre-populated with data, that then expands and renders all the required HTML and CSS inside the user's browser.

Next.JS differs in this approach in that it can pre-render or "server render" the HTML and CSS before the Javascript bundle gets sent to the browser and therefore provide a more robust user experience by sending the HTML and CSS alongside the Javascript. The bundled Javascript file then gets expanded on top of the already existing HTML and CSS, allowing for the rich interactivity provided through ReactJS.

The advantages here are significant: for one the loading experience is faster as the HTML and CSS coming from the server display right away vs. awaiting the Javascript file to unbundle and render the HTML and CSS. Additionally in case the browser is unable to execute the javascript bundle because of an incompatibility (ex. using legacy browsers such as IE 10), we were able to create fallback solutions using the already rendered HTML and CSS. Most important, however, is that using Next.JS allows developer to use the same code base they use on the front-end of their application to also run on the back-end, significantly reducing the amount of complexity.

Lastly, our initial evaluation of NextJS showed that it worked well with a number of other Javascript components such as user interface libraries, search, and translation.

#### How can I get started?

Check out the Quickstart documentation in our README.md. You can also look at the [Next.JS](https://nextjs.org/learn/ "Next.JS") tutorial site to learn more.

### Styling The App

Elements in the application are styled with [MaterialUI](https://material-ui.com/) themes and [Emotion](https://emotion.sh/docs/introduction) CSS-in-JS styles.

The MaterialUI global [theme](https://material-ui.com/customization/themes/#themes) is customized in themes.js. The globalTheme variable can be imported and have its values be referenced in other components. Font families, theme colours, and screen size breakpoints are the most common uses of the globalTheme object.

Individual component styling is handled by the Emotion library, through a combination of the [css prop](https://emotion.sh/docs/css-prop), and [styled components](https://emotion.sh/docs/styled).

### [AirTable](/doc/AIRTABLE.md)

### Using Heroku

#### What is it?

[Heroku](https://www.heroku.com) is a "platform as a service" that enables developers to build, run,
and operate applications entirely in the cloud. In particular, Heroku allows quick and easy deployment of apps,
either manually through a CLI or through the Heroku web interface.

#### Why and how are we using it?

We are using Heroku for two purposes:

- to allow us to quickly deploy a fixed branch to the web
  (for user and accessibility testing, and the VAC Working Group), and
- to create apps from branches to help with pull request review

To create a one-off app:

- Use the "New" button in the upper right corner, and click "Create new app".
- Give the app a name and click "Create app".
- The app's page opens. Under Deploy, connect the app to GitHub and a specific repo.
- choose a branch to deploy.

Heroku also automatically creates an app for each PR in our repository. This is extremely useful for code review.
Heroku will add a link to the app in the GitHub PR.

To set up PR review apps we use a Heroku Pipeline. From the dashboard:

- Click New / Create new pipeline.
- Give the pipeline a name, connect it to a repo and click "Create pipeline".
- Add an existing app (or create a new one) to the Staging or Production sections.
  The review apps will inherit environment variables from this app.
- Click "Enable Review Apps".
- Check the box next to "Create new review apps for new pull requests automatically".
- Click "Enable".

#### How does one get access?

To join the CDS Heroku team, create a (free) Heroku account and email vac@cds-snc.ca
with your account details so we can add you to the team.
Note that our PR apps are automatically created by Heroku, so developers do not require Heroku access
to have review apps created for their PRs.

### Using CircleCI

#### What is it?

[CircleCI](https://circleci.com/) is a cloud service that performs continuous integration testing and continuous deployment.

#### Why and how are we using it?

CircleCI is connected to our GitHub repository (see the project's [CircleCI page](https://circleci.com/gh/veteransaffairscanada/vac-benefits-directory)). For every new commit, CircleCI runs our test suite and reports any
failures. If a commit to master fails testing we are notified on the CDS `vac-devs` Slack channel.
If a commit to master passes, CircleCI builds a dockerfile from master and pushes it to DockerHub.
CircleCI is configured via [`config.yml`](/.circleci/config.yml).

#### How does one get access?

You can view a commit's test report without having admin access to our CircleCI account, but you will need this access to
change some parts of CircleCI configuration (in particular, to add environment variables to CircleCI). Talk to one of the
other developers to get access.

### Test Driven Development

#### What is it?

[Test Driven Development](https://en.wikipedia.org/wiki/Test-driven_development "Test Driven Developement") and other practices associated with "small a" [Agile](https://en.wikipedia.org/wiki/Agile_software_development "Agile") are a set of frameworks and tools to manage development of a software product.

#### Why are we using it?

Test driven development allows for an iterative and continuous approach that is preferable to segmented release cycles. To facilitate this process, we have chosen to use a [Continous Integration](https://en.wikipedia.org/wiki/Continuous_integration "Continous Integration") and [Continous Delivery](https://en.wikipedia.org/wiki/Continuous_delivery "Continous Delivery") process whereby new features and code are added to the product frequently, reviewed and verified, and shipped as soon as they are done. We are currently using [https://circleci.com/](https://circleci.com/ "Circle CI") as our platform for running all our unit tests before deploying. Alongside that we are also using [https://heroku.com](https://heroku.com "Heroku") to create staging versions of our application for manual review.

#### What is our development process?

1. Development sprints are given two week spans of time
2. At the beginning of a sprint, the development team meets with the other members of the larger team to discuss development priorities for new features.
3. The development team reviews open issues from the last sprint and prioritizes them with the next development targets.
4. Features are broken down into issues on GitHub and developers agree on how much time each issue potentially can take
5. Developers self-assign issues from the list of open issues in GitHub.
6. To resolve an issue a developer:
   - Checks out a new branch from `master`
   - Builds the feature or resolves the bug described in the issue
   - Continuously commits code to their branch at sensible intervals
   - Writes unit and integration tests for the code they have added
   - Changes/removes unit and integration tests for code they have modified
   - Runs the test suite that ensure all tests pass
   - Uses a code coverage tool to ensure all significant logic has been tested
   - Commits the final code, pushes the code to GitHub, and opens a pull request in GitHub
   - Awaits CircleCI to verify that all our tests will pass
   - Spot check features using Heroku review apps
   - Requests other members of the team to review the pull request - only one review is required, but all team members are invited to review the pull request
   - If other team members have comments, they will note these in GitHub for the developer to either fix them or discuss
   - Other team members approve the pull request once all open discussion has been resolved
   - Pull requests are then merged into `master`
   - CircleCI verifies once again that all tests pass on the updated `master` and deploys the code into production
7. This process is repeated iteratively until all issues for a sprint are resolved and new set of issues can be created or until a new sprint starts.
8. At the end of a sprint the development team reviews the issues completed and suggest improvements on for the next sprint.

#### What are the advantages

The advantages of this process is that features get broken down and reviewed by the entire development team before work. This gives line of sight to the whole team on what is being worked on. Additionally anything being worked on is easily manageable by the person writing the code, as well as understandable by the person reviewing it. Using testing as the foundational practice allows for a high degree of confidence in the functionality of the code base. It also for allows instant feedback if a developer breaks existing functionality. Based on this high degree of confidence it allows a model of continuous delivery which ensures that stake holders and customers receive the features once they are ready vs. when they can be scheduled for release.

### Using BrowserStack

#### What is it?

[BrowserStack](https://www.browserstack.com) is a cloud service that allows instant access to over 1000 real devices and browsers.

#### Why and how are we using it?

We use BrowserStack to test our app on other devices and browsers. In particular, since our development machines are MacBooks we need
an easy method to test on Windows / Internet Explorer. We use BrowserStack in two ways

- as a live platform to evaluate the app manually
- as a host for automated testing (described below)

#### How does one get access?

Create a personal account on BrowserStack and then contact a developer to get your account associated with the CDS account.

### Deployment

#### How are we deploying the application?

To standardize the environments between testing and production we are using [Docker](https://www.docker.com/), which allows us to create the same software conditions throughout our release pipeline. Docker allows us to create a specific environment from which the application should run, defined through the [Dockerfile](https://github.com/veteransaffairscanada/vac-benefits-directory/blob/master/Dockerfile) inside our main repository. Docker executes this file and builds a container image, which then can be deployed on any infrastructure that supports container images (Azure, AWS, Google Cloud, etc.)

#### What is the current deployment workflow?

When a pull request is approved the developer merges the branch into `master`. CircleCI receives a notification and starts running all the tests for the application. If all test pass, CircleCI then uses the Docker executable to build a Docker image. It then pushes the Docker image to a container registry. A container registry is simply a collection of images available to a specific organization or user. Once the registry has received the image it notifies the deployment platform (Azure in this case), that a new image is available. Azure then downloads the image from the container registry and deploys it to its own container service. The container service has already been configured to accept certain DNS requests and to route the requests appropriately (this is usually outside of the scope of this applications deployment configuration).

#### How is this different from the testing workflow?

The testing workflow is different from deployment, but is also initiated by developer actions on GitHub. When a developer creates a new bug / feature branch it notifies CircleCI to run the tests on the code contained inside the branch. It also triggers a Heroku build so that other developers can see the changes in action without having to run the branch locally. In the other scenario, the developer merges a branch into `master`. This also notifies CircleCI, but because it is `master` triggers the Docker build process if all tests pass. The result of the Docker build process is what then gets deployed to the production server.

The following diagram demonstrates both flows:

![Test and deploy workflow](https://user-images.githubusercontent.com/867334/44407480-31f3b780-a52c-11e8-97d7-6cf8ad046019.png "Test and deploy workflows")

### Translations

#### Why are we translating our content?

Given the Government of Canada's mandate to support both official languages, we use `react-18next` [https://react.i18next.com](https://react.i18next.com/ "react-18next") to allow us on-the-fly translations of all the text visible on a given page.

#### How does it work?

The process to translate text is to pull translated `key`-`value` strings out of static JSON files that correspond with the locale set for the browser, or a `lng` GET param set in the URL. This requires any modification or addition of translation strings to go through a `commit` cycle in Git, limiting accessibility to business owners and other non-technical users. Instead we are storing all translatable strings in `AirTable` where they can be easily modified using a user interface similar to Excel.

Upon boot, and every hour after, the server will download and cache all the translation strings in memory (A refresh of the cache can also be requested upon demand). The strings are then stored in `redux` and made available to all `react` components. A `translation` function then takes the `key` of a string and looks up the matching value in the corresponding locale.

When a new string is added to `AirTable`, both an English and a French version are included. If the person adding the string is not comfortable in both official languages they are encouraged to add a `[fra]` in front of the translation that they are uncomfortable with. This allows other members of the team to see the incomplete translation both in `AirTable` and the actual application, allowing them to fix the string if they have sufficient proficiency.

### Using Snyk

#### What is it?

[Snyk](https://snyk.io/) is a cloud service that automates finding & fixing vulnerabilities in our dependencies.

#### Why and how are we using it?

Synk gives us a real-time evaluation of the modules we are using in our app.
Snyk is integrated with our GitHub repository and provides us with information in two ways:

- Snyk is run on master with every merge, and the results reported on a badge at the top of [README.md](/README.md).
  Additionally, the development team receives a weekly email from Snyk detailing any vulnerabilities found.
- Synk runs on every pull request, and the results are reported in the PR.

#### How does one get access?

Talk to a developer to get access to our Synk account.

### Biweekly code review

As mentioned above we use Synk to constantly monitor our code for vulnerabilities, and respond as required to any new vulnerabilities found in our app.
In addition to this, at the start of every two week sprint we do a security review and update. Currently this entails:

- listing any new software development tools we are using, and signing up for the appropriate security bulletins
- reviewing and updating the packages we are using in the project
- running end-to-end tests on Windows (via BrowserStack) and noting any issues that arise (`yarn test:e2e_windows`)

See [SECURITY.md](/en/SECURITY.md) for more details

### Testing

We are using a combination of unit tests and end-to-end tests to validate the code base. Unit tests are written
using [`jest`](https://jestjs.io/) and [`enzyme`](https://airbnb.io/enzyme/). We have made the decision not to test for
correct styling, but rather focus on the logic in the components. We currently have over 200 tests that are run by CircleCI
on every commit. PRs are not approved if code is added to the app without sufficient testing. PRs should not be merged
if the tests do not pass.

We are using [Cypress](https://www.cypress.io) to write end-to-end tests. The e2e test suite can be run locally via `yarn cypress:run` (with `yarn start` running).

### Code documentation

We are currently using [React Styleguidist](https://react-styleguidist.js.org/) to create easily accessible HTML output of our React components code comments. This documentation can be found in the `documentation` directory. To interactively generate the documentation you can run `yarn docs`, which will start a web server from which you can view the generated output. The output will update as you adjust comments inside the react components. To generate the static HTML output, please run `yarn docs:build`.

### Contributing to GitHub repo

Download GitHub desktop @ https://desktop.github.com/.
Go to https://github.com/veteransaffairscanada/vac-benefits-directory
click "Clone or download" button and select open in desktop.
Select where you would like to save the project locally.

When making changes first make a new branch.
Click Branch in the top left corner, then new branch.

After making your changes commit those changes in GitHub desktop then select push changes in the top right corner.
Navigate over to the GitHub page https://github.com/veteransaffairscanada/vac-benefits-directory and find the branch. Then create a new pull request to better explain what changes you have implemented.
After that the pull request will be available for reviewers to look at and make sure everything looks good before merging it into master.

### Pair programming

#### What is it?

[Pair programming](https://en.wikipedia.org/wiki/Pair_programming) is where 2 developers work together on the same task using the same workstation.

#### Why and how are we using it?

- to quickly onboard developers new to the project - knowledge transfer happens quickly when pairing with a developer who knows the codebase
- to work on difficult features where 2 brains are an advantage
- for fun!

When the 2 developers are not in the same location, we have accomplished pairing with the following:

- Phone call for voice - this is the most reliable if there is a slow network connection on 1 or more end.
- [Atom](https://atom.io/) with Teletype for writing code
- [Slack](https://slack.com/) for screen sharing, so the observer can see things outside the text editor like tests being run in terminal, what it looks like in the browser, etc.

#### How does one get set up?

To set up Atom for pair programming, do the following:

1. Download and install Atom: [https://atom.io/](https://atom.io/)
2. Open Atom -> Preferences -> Install, and search for "Teletype"
3. Install Teletype. A Teletype icon (looks like a radio tower) should appear at the bottom of your screen.
4. Click the Teletype icon and authorize it using your GitHub credentials
5. Go back to Atom, click the Teletype icon again and you should now be able to share your workspace or join a portal by pasting in the link to another person's workspace.

### Deployment notifications

#### What is it?

Deployment notifications are automated messages that we send to our internal Slack channel to notify us when the application has been deployed.

#### How do they work?

Upon server start the the application will send a JSON payload to a [Slack incoming webhook](https://api.slack.com/incoming-webhooks "Incoming Webhook"). The webhook then translates the information into a nicely formatted slack message that all developers can see. You can learn more about how they exactly work [here](https://github.com/veteransaffairscanada/vac-benefits-directory/blob/master/utils/deploy_notification.js). Important is that you set a `WEBHOOK_URL` environmental variable which is the URL of your Slack Webhook.

#### What do we use them for?

We primarily use the deploy notification to ensure that our production release are making it onto the production server. Each notification includes a link to the pull request that was merged into `master` as well as a timestamp of when the server finished starting up. This allows us to determine how long a production deploy takes after we kick off a production build. Currently from starting the build to deployment takes ~8 minutes.

## ---------------------------------------------------------------------

## Documentation

### Table des mati√®res

- [Next.JS et le rendu c√¥t√© serveur](#nextjs-et-le-rendu-c√¥t√©-serveur)
- [AirTable](/doc/fr/AIRTABLE.md)
- [Heroku](#heroku)
- [CircleCI](#circleci)
- [D√©veloppement pilot√© par les tests](#d√©veloppement-pilot√©-par-les-tests)
- [BrowserStack](#browserstack)
- [D√©ploiement](#d√©ploiement)
- [Traductions](#traductions)
- [Snyk](#snyk)
- [Tests](#tests)
- [Documentation sur le code](#documentation-sur-le-code)
- [Contribuer au r√©pertoire de GitHub](#contribuer-au-r√©pertoire-de-github)
- [Programmation en bin√¥me](#programmation-en-bin√¥me)
- [Notifications de d√©ploiement](#notifications-de-d√©ploiement)

### Next.JS et le rendu c√¥t√© serveur

#### De quoi s‚Äôagit-il?

[Next.JS](https://github.com/zeit/next.js/ "Next.JS") (en anglais) est un cadre JavaScript pour des applications React rendues c√¥t√© serveur.

#### Pourquoi l‚Äôutilisons-nous?

La justification du choix de Next.JS d√©coule des crit√®res suivants :

- utilisation de JavaScript √† la fois dans la partie frontale (_front-end_) et la partie dorsale (_back-end_);
- capacit√© de rendre des pages enti√®rement au format HTML et CSS sur le serveur;
- soutien solide des d√©veloppeurs et vaste environnement tiers.

Pour fournir l‚Äôexp√©rience utilisateur la plus √©l√©gante et moderne possible, [ReactJS](https://reactjs.org/ "ReactJS") a √©t√© choisi comme le cadre frontal principal. Traditionnellement, les applications ReactJS sont √©labor√©es comme deux services distincts, l‚Äôun du c√¥t√© serveur et l‚Äôautre du c√¥t√© client, avec des bases de code individuelles et souvent dans diff√©rents langages de programmation. Lorsqu‚Äôun utilisateur fait une demande par rapport √† une application avec une telle architecture, il t√©l√©charge g√©n√©ralement un fichier JavaScript group√©, pr√©rempli avec des donn√©es, qui s‚Äô√©largit par la suite et rend tous les fichiers HTML et CSS dans le navigateur de l‚Äôutilisateur.

Next.JS diff√®re dans cette approche en ce sens qu‚Äôil peut rendre au pr√©alable ou ¬´ rendre au moyen du serveur ¬ª les fichiers HTML et CSS avant que le groupe JavaScript soit envoy√© au navigateur, et donc fournir une exp√©rience utilisateur plus solide en envoyant des fichiers HTML et CSS avec le JavaScript. Le fichier JavaScript group√© est ensuite √©largi en plus des fichiers HTML et CSS d√©j√† existants, permettant la forte interactivit√© offerte au moyen de ReactJS.

Les avantages sont importants : par exemple, l‚Äôexp√©rience de t√©l√©chargement est plus rapide puisque les fichiers HTML et CSS venant du serveur s‚Äôaffichent tout de suite, par rapport √† l‚Äôattente du fichier JavaScript pour d√©grouper et rendre les fichiers HTML et CSS. De plus, si le navigateur n‚Äôest pas en mesure d‚Äôex√©cuter le groupe JavaScript √† cause d‚Äôune incompatibilit√© (par exemple, l‚Äôutilisation d‚Äôanciens navigateurs comme IE 10), nous pouvons cr√©er des solutions de rechange √† l‚Äôaide des fichiers HTML et CSS d√©j√† rendus. Toutefois, le plus important est que l‚Äôutilisation de Next.JS permet aux d√©veloppeurs d‚Äôutiliser dans la partie dorsale la m√™me base de code qu‚Äôils utilisent dans la partie frontale de leur application, ce qui permet de r√©duire consid√©rablement le niveau de complexit√©.

Enfin, notre √©valuation initiale de NextJS a montr√© qu‚Äôil fonctionnait bien avec un certain nombre d‚Äôautres composantes de JavaScript, comme les biblioth√®ques d‚Äôinterface utilisateur, la recherche et la traduction.

#### Comment puis-je commencer?

Consultez la documentation de d√©marrage rapide dans notre fichier README.md. Vous pouvez aussi consulter le site du tutoriel de [Next.JS](https://nextjs.org/learn/ "Next.JS") pour en apprendre davantage.

### [AirTable](/doc/AIRTABLE.md)

### Heroku

#### De quoi s‚Äôagit-il?

[Heroku](https://www.heroku.com) (en anglais) est une ¬´ plateforme comme service ¬ª qui permet aux d√©veloppeurs de d√©velopper, d‚Äôex√©cuter et d‚Äôexploiter des applications enti√®rement dans le nuage. En particulier, Heroku permet le d√©ploiement rapide et facile d‚Äôapplications, soit manuellement au moyen d‚Äôune interface de ligne de commandes ou de l‚Äôinterface Web de Heroku.

#### Pourquoi et comment l‚Äôutilisons-nous?

Nous utilisons Heroku √† deux fins :

- pour nous permettre de d√©ployer rapidement une branche fixe dans le Web (pour les tests d‚Äôutilisation et d‚Äôaccessibilit√©, et le Groupe de travail d‚ÄôACC);
- pour cr√©er des applications √† partir des branches en vue de faciliter l‚Äôexamen des demandes de tirage.

Pour cr√©er une application ponctuelle :

- Utilisez le bouton ¬´ New ¬ª, dans le coin sup√©rieur droit, et cliquez sur ¬´ Create new app ¬ª.
- Donnez un nom √† l‚Äôapplication et cliquez sur ¬´ Create app ¬ª.
- La page de l‚Äôapplication s‚Äôouvre. Sous Deploy, connectez l‚Äôapplication √† GitHub et √† un r√©pertoire pr√©cis.
- S√©lectionnez une branche √† d√©ployer.

De m√™me, Heroku cr√©e automatiquement une application pour chaque demande de tirage dans notre r√©pertoire. Cela est extr√™mement utile pour l‚Äôexamen des codes. Heroku ajoutera un lien vers l‚Äôapplication dans la demande de tirage de GitHub.

Pour configurer des applications d‚Äôexamen des demandes de tirage, nous utilisons un pipeline Heroku. Dans le tableau de bord :

- Cliquez sur New / Create new pipeline.
- Donnez un nom au pipeline, connectez-le √† un r√©pertoire et cliquez sur ¬´ Create pipeline ¬ª.
- Ajoutez une application existante (ou cr√©ez-en une nouvelle) dans les sections Staging ou Production. Les applications d‚Äôexamen h√©riteront des variables d‚Äôenvironnement de cette application.
- Cliquez sur ¬´ Enable Review Apps ¬ª.
- Cochez la case √† c√¥t√© de ¬´ Create new review apps for new pull requests automatically ¬ª.
- Cliquez sur ¬´ Enable ¬ª.

#### Comment peut-on y avoir acc√®s?

Pour vous joindre √† l‚Äô√©quipe Heroku du SNC, cr√©ez un compte Heroku (gratuit) et envoyez un courriel √† vac@cds-snc.ca comprenant les d√©tails sur votre compte afin que nous puissions vous ajouter √† l‚Äô√©quipe. Veuillez noter que nos applications de demande de tirage sont automatiquement cr√©√©es par Heroku, par cons√©quent les d√©veloppeurs n‚Äôont pas besoin d‚Äôun acc√®s Heroku pour que des applications d‚Äôexamen soient cr√©√©es pour leurs demandes de tirage.

### CircleCI

#### De quoi s‚Äôagit-il?

[CircleCI](https://circleci.com/) (en anglais) est un service infonuagique qui effectue des tests d‚Äôint√©gration continus et un d√©ploiement continu.

#### Pourquoi et comment l‚Äôutilisons-nous?

CircleCI est reli√© √† notre r√©pertoire GitHub (voir la [page CircleCI](https://circleci.com/gh/veteransaffairscanada/vac-benefits-directory)) (en anglais) du projet). Pour chaque nouvelle validation (_commit_), CircleCI ex√©cute notre s√©rie de tests et signale tous les √©checs. Si une validation de la branche ma√Ætre √©choue aux tests, nous en sommes inform√©s sur le canal Slack du SNC `vac-devs`.
Si une validation de la branche ma√Ætre r√©ussit, CircleCI √©labore un dockerfile √† partir de la branche ma√Ætre et l‚Äôenvoie dans DockerHub. CircleCI est configur√© au moyen de [`config.yml`](/.circleci/config.yml).

#### Comment peut-on y avoir acc√®s?

Vous pouvez consulter le rapport de test de validation sans avoir un acc√®s administrateur √† notre compte CircleCI, mais vous aurez besoin de cet acc√®s pour modifier certaines parties de la configuration de CircleCI (en particulier, pour ajouter des variables d‚Äôenvironnement √† CircleCI). Parlez √† l‚Äôun des autres d√©veloppeurs pour obtenir l‚Äôacc√®s.

### D√©veloppement pilot√© par les tests

#### De quoi s‚Äôagit-il?

Le [d√©veloppement pilot√© par les tests](https://fr.wikipedia.org/wiki/Test_driven_development) et d‚Äôautres pratiques li√©es √† [Agile](https://fr.wikipedia.org/wiki/M%C3%A9thode_agile) avec un ¬´ petit a ¬ª constituent un ensemble de cadres et d‚Äôoutils pour g√©rer le d√©veloppement d‚Äôun produit logiciel.

#### Pourquoi l‚Äôutilisons-nous?

Le d√©veloppement pilot√© par les tests permet une approche it√©rative et continue qui est pr√©f√©rable aux cycles de lancement r√©partis. Pour faciliter ce processus, nous avons choisi d‚Äôutiliser un processus d‚Äô[int√©gration continue](https://fr.wikipedia.org/wiki/Int%C3%A9gration_continue) et de [livraison continue](https://fr.wikipedia.org/wiki/Livraison_continue) selon lequel de nouvelles fonctionnalit√©s et de nouveaux codes sont fr√©quemment ajout√©s au produit, examin√©s et v√©rifi√©s, puis exp√©di√©s d√®s qu‚Äôils sont achev√©s. On utilise actuellement [https://circleci.com](https://circleci.com) (en anglais) comme plateforme pour ex√©cuter tous nos tests unitaires avant le d√©ploiement. Avec cela, nous utilisons √©galement [https://heroku.com](https://heroku.com) (en anglais) pour cr√©er des versions interm√©diaires de notre application aux fins d‚Äôexamen manuel.

#### Quel est notre processus de d√©veloppement?

1. On donne aux sprints de d√©veloppement des p√©riodes de deux semaines.
2. Au d√©but d‚Äôun sprint, l‚Äô√©quipe de d√©veloppement se r√©unit avec les autres membres de la grande √©quipe afin de discuter des priorit√©s de d√©veloppement des nouvelles fonctionnalit√©s.
3. L‚Äô√©quipe de d√©veloppement examine les probl√®mes non r√©solus depuis le dernier sprint et leur accorde la priorit√© dans les prochains objectifs de d√©veloppement.
4. Les fonctionnalit√©s sont r√©parties en probl√®mes sur GitHub, et les d√©veloppeurs s‚Äôentendent sur le temps que chaque probl√®me pourrait prendre.
5. Les d√©veloppeurs s‚Äôattribuent des probl√®mes √† partir de la liste de probl√®mes non r√©solus dans GitHub.
6. Pour r√©soudre un probl√®me, un d√©veloppeur :

- consulte une nouvelle branche du `master`;
- √©labore la fonctionnalit√© ou r√©sout le bogue d√©crit dans le probl√®me;
- valide continuellement le code dans sa branche √† des intervalles raisonnables;
- √©crit des tests unitaires et d‚Äôint√©gration pour le code qu‚Äôil a ajout√©;
- modifie ou supprime les tests unitaires et d‚Äôint√©gration pour le code qu‚Äôil a modifi√©;
- ex√©cute une s√©rie de tests pour s‚Äôassurer que tous les tests sont r√©ussis;
- utilise un outil de couverture de code pour s‚Äôassurer que toute la logique importante a √©t√© test√©e;
- valide le code final, pousse le code dans GitHub et ouvre une demande de tirage dans GitHub;
- attend CircleCI pour v√©rifier que tous nos tests seront r√©ussis;
- effectue des v√©rifications ponctuelles √† l‚Äôaide des applications d‚Äôexamen d‚ÄôHeroku;
- demande aux autres membres de l‚Äô√©quipe d‚Äôexaminer la demande de tirage ‚Äì un seul examen est requis, mais on invite tous les membres de l‚Äô√©quipe √† examiner la demande de tirage;
- si d‚Äôautres membres de l‚Äô√©quipe ont des commentaires, ils les indiqueront dans GitHub pour que le d√©veloppeur corrige des erreurs ou en discute;
- d‚Äôautres membres de l‚Äô√©quipe approuvent la demande de tirage une fois que toutes les discussions en suspens ont √©t√© r√©solues;
- les demandes de tirage sont ensuite fusionn√©es dans `master`;
- CircleCI v√©rifie encore une fois que tous les tests sont r√©ussis sur le `master` √† jour et d√©ploie le code en production.

7. Ce processus est r√©p√©t√© de fa√ßon it√©rative jusqu‚Äô√† ce que tous les probl√®mes pour un sprint soient r√©gl√©s et qu‚Äôune nouvelle s√©rie de probl√®mes puisse √™tre cr√©√©e ou jusqu‚Äô√† ce qu‚Äôun nouveau sprint d√©marre.
8. √Ä la fin d‚Äôun sprint, l‚Äô√©quipe de d√©veloppement examine les probl√®mes et sugg√®re des am√©liorations pour le prochain sprint.

#### Quels sont les avantages?

Les avantages de ce processus sont que les fonctionnalit√©s sont r√©parties et examin√©es par l‚Äôensemble de l‚Äô√©quipe de d√©veloppement avant le travail. Cela donne la ligne de vis√©e √† toute l‚Äô√©quipe sur le travail en cours. De plus, tout le travail en cours est facilement g√©rable par la personne qui √©crit le code, et compr√©hensible pour la personne qui l‚Äôexamine. L‚Äôutilisation des tests comme pratique de base permet un niveau √©lev√© de confiance dans la fonctionnalit√© de la base de code. Cela permet √©galement une r√©troaction instantan√©e si un d√©veloppeur brise la fonctionnalit√© existante. En fonction de ce niveau de confiance √©lev√©, ce processus favorise un mod√®le de livraison continue qui veille √† ce que les parties prenantes et les clients re√ßoivent les fonctionnalit√©s une fois qu‚Äôelles sont pr√™tes par rapport au moment o√π l‚Äôon peut planifier leur lancement.

### BrowserStack

#### De quoi s‚Äôagit-il?

[BrowserStack](https://www.browserstack.com) (en anglais) est un service infonuagique qui permet l‚Äôacc√®s instantan√© √† plus de 1000 appareils et navigateurs r√©els.

#### Pourquoi et comment l‚Äôutilisons-nous?

Nous utilisons BrowserStack pour tester notre application sur d‚Äôautres appareils et navigateurs. En particulier, √©tant donn√© que nos machines de d√©veloppement sont des MacBook, nous avons besoin d‚Äôune m√©thode facile pour effectuer des tests sur Windows/Internet Explorer. Nous utilisons BrowserStack de deux fa√ßons :

- comme une plateforme en direct pour √©valuer l‚Äôapplication manuellement;
- comme un h√¥te pour les tests automatis√©s (d√©crits ci-dessous).

#### Comment peut-on y avoir acc√®s?

Cr√©ez un compte personnel sur BrowserStack puis communiquez avec un d√©veloppeur pour associer votre compte au compte du SNC.

### D√©ploiement

#### Comment d√©ployons-nous l‚Äôapplication?

Afin de normaliser les environnements entre les tests et la production, nous utilisons [Docker](https://www.docker.com/) (en anglais), qui nous permet de cr√©er les m√™mes conditions logicielles dans le pipeline de mise en production. Docker nous permet de cr√©er un environnement pr√©cis dans lequel l‚Äôapplication doit s‚Äôex√©cuter, d√©fini au moyen du [Dockerfile](https://github.com/veteransaffairscanada/vac-benefits-directory/blob/master/Dockerfile) (en anglais) dans notre r√©pertoire principal. Docker ex√©cute ce fichier et construit une image de conteneur, que l‚Äôon peut ensuite d√©ployer sur n‚Äôimporte quelle infrastructure qui prend en charge des images de conteneur (Azure, AWS, Google Cloud, entre autres).

#### Quel est le flux de production actuel du d√©ploiement?

Lorsqu‚Äôune demande de tirage est approuv√©e, le d√©veloppeur fusionne la branche √† `master`. CircleCI re√ßoit un avis et commence √† ex√©cuter tous les tests pour l‚Äôapplication. Si tous les tests sont r√©ussis, CircleCI utilise ensuite le fichier ex√©cutable Docker pour construire une image Docker. Il pousse ensuite l‚Äôimage Docker dans un registre conteneur. Un registre conteneur est tout simplement une collection d‚Äôimages disponibles √† une organisation ou √† un utilisateur particulier. Une fois que le registre a re√ßu l‚Äôimage, il informe la plateforme de d√©ploiement (Azure dans ce cas) qu‚Äôune nouvelle image est disponible. Par la suite, Azure t√©l√©charge l‚Äôimage du registre conteneur et la d√©ploie dans son propre service conteneur. Le service conteneur a d√©j√† √©t√© configur√© pour accepter certaines demandes de DNS et pour acheminer les demandes de fa√ßon appropri√©e (cela se trouve g√©n√©ralement hors de la port√©e de cette configuration de d√©ploiement des applications).

#### Comment cela diff√®re-t-il du flux de production de tests?

Le flux de production de tests est diff√©rent du d√©ploiement, mais est aussi lanc√© par les actions du d√©veloppeur dans GitHub. Lorsqu‚Äôun d√©veloppeur cr√©e une nouvelle branche de bogues ou de fonctionnalit√©s, il indique √† CircleCI d‚Äôex√©cuter des tests sur le code qui se trouve dans la branche. Il d√©clenche √©galement un d√©veloppement Heroku afin que d‚Äôautres d√©veloppeurs puissent voir les changements en action sans devoir ex√©cuter la branche localement. Dans l‚Äôautre sc√©nario, le d√©veloppeur fusionne une branche √† `master`. Cela avise √©galement CircleCI, mais parce que master d√©clenche le processus de d√©veloppement Docker si tous les tests sont r√©ussis. Le r√©sultat du processus de d√©veloppement Docker est ensuite ce qui est d√©ploy√© au serveur de production.

Le diagramme suivant d√©montre les deux flux :

![Test and deploy workflow](https://user-images.githubusercontent.com/867334/44407480-31f3b780-a52c-11e8-97d7-6cf8ad046019.png "Test and deploy workflows")

### Traductions

#### Pourquoi traduisons-nous notre contenu?

√âtant donn√© que le mandat du gouvernement du Canada est d‚Äôappuyer les deux langues officielles, nous utilisons `react-18next` [https://react.i18next.com](https://react.i18next.com/ "react-18next") (en anglais) pour nous permettre d‚Äôeffectuer des traductions √† la vol√©e de tout le texte visible sur une page donn√©e.

#### Comment fonctionne-t-il?

Le processus de traduction de texte consiste √† tirer des cha√Ænes `key`-`value` traduites des fichiers JSON statiques qui correspondent aux param√®tres r√©gionaux √©tablis pour le navigateur, ou un param√®tre `lng` GET √©tabli dans l‚Äôadresse URL. Cela exige que des modifications ou des ajouts de cha√Ænes de traduction passent par un cycle `commit` dans Git, ce qui limite l‚Äôaccessibilit√© aux propri√©taires d‚Äôentreprise et aux autres utilisateurs non techniques. Au lieu de cela, nous stockons toutes les cha√Ænes traduisibles dans `AirTable` o√π l‚Äôon peut facilement les modifier √† l‚Äôaide d‚Äôune interface utilisateur semblable √† Excel.

Au d√©marrage, et chaque heure par la suite, le serveur t√©l√©chargera et mettra en cache toutes les cha√Ænes de traduction dans la m√©moire (une actualisation de la m√©moire cache peut √©galement √™tre exig√©e sur demande). Les cha√Ænes sont ensuite stock√©es dans `redux` et mises √† la disposition de toutes les composantes `react`. Une fonctionnalit√© `translation` prend alors la cl√© d‚Äôune cha√Æne et examine la valeur correspondante dans les param√®tres r√©gionaux correspondants.

Lorsqu‚Äôune nouvelle cha√Æne est ajout√©e √† `AirTable`, une version anglaise et une version fran√ßaise sont incluses. Si la personne qui ajoute la cha√Æne n‚Äôest pas √† l‚Äôaise dans les deux langues officielles, on l‚Äôencourage √† ajouter un `[fra]` devant la traduction avec laquelle elle n‚Äôest pas √† l‚Äôaise. Cela permet aux autres membres de l‚Äô√©quipe de voir la traduction incompl√®te dans `AirTable` et dans l‚Äôapplication r√©elle, ce qui leur permet de corriger la cha√Æne s‚Äôils ont une comp√©tence suffisante.

### Snyk

#### De quoi s‚Äôagit-il?

[Snyk](https://snyk.io/) (en anglais) est un service infonuagique qui automatise la recherche et la correction des vuln√©rabilit√©s dans nos d√©pendances.

#### Pourquoi et comment l‚Äôutilisons-nous?

Snyk nous donne une √©valuation en temps r√©el des modules que nous utilisons dans notre application. Snyk est int√©gr√© √† notre r√©pertoire GitHub et nous fournit des renseignements de deux fa√ßons :

- Snyk s‚Äôex√©cute sur la branche ma√Ætre avec chaque fusion, et les r√©sultats sont rapport√©s sur un badge dans la partie sup√©rieure de [README.md](/README.md) (en anglais). De plus, l‚Äô√©quipe de d√©veloppement re√ßoit un courriel hebdomadaire de Snyk d√©crivant toutes les vuln√©rabilit√©s trouv√©es.
- Snyk s‚Äôex√©cute sur chaque demande de tirage, et les r√©sultats sont communiqu√©s dans la demande de tirage.

#### Comment peut-on y avoir acc√®s?

Parlez √† un d√©veloppeur pour avoir acc√®s √† notre compte Snyk.

### Examen bihebdomadaire des codes

Comme nous l‚Äôavons mentionn√© plus haut, nous utilisons Snyk pour surveiller constamment notre code pour trouver des vuln√©rabilit√©s, et intervenir au besoin √† toutes nouvelles vuln√©rabilit√©s dans notre application. De plus, au d√©but de chaque sprint bihebdomadaire, nous effectuons un examen de s√©curit√© et une mise √† jour. √Ä l‚Äôheure actuelle, cela comprend :

- √©num√©rer tout nouvel outil de d√©veloppement de logiciel que nous utilisons, et nous abonner aux bulletins de s√©curit√© appropri√©s;
- examiner et mettre √† jour les progiciels que nous utilisons dans le projet;
- ex√©cuter des tests de bout en bout sur Windows (√† l‚Äôaide de BrowserStack) et signaler tous les probl√®mes qui se pr√©sentent (`yarn test:e2e_windows`).

Consultez [SECURITE.md](/fr/SECURITE.md) pour plus de renseignements.

### Tests

Nous utilisons une combinaison de tests unitaires et de tests de bout en bout pour valider la base de code. Les tests unitaires sont r√©dig√©s √† l‚Äôaide de [`jest`](https://jestjs.io/) et [`enzyme`](https://airbnb.io/enzyme/). Nous avons d√©cid√© de ne pas tester le style appropri√©, mais plut√¥t de nous concentrer sur la logique dans les composantes. √Ä l‚Äôheure actuelle, nous avons plus de 200 tests qui sont ex√©cut√©s par CircleCI sur chaque validation. Les demandes de tirage ne sont pas approuv√©es si le code est ajout√© √† l‚Äôapplication sans assez de tests. Les demandes de tirage ne doivent pas √™tre fusionn√©es si les tests ne sont pas r√©ussis.

Nous utilisons [Cypress](https://www.cypress.io) (en anglais) pour √©crire des tests de bout en bout. La s√©rie de tests e2e peut √™tre ex√©cut√©e localement au moyen de `yarn cypress:run` (avec l‚Äôex√©cution de `yarn start`).

### Documentation sur le code

Nous utilisons actuellement [React Styleguidist](https://react-styleguidist.js.org/) (en anglais) pour cr√©er facilement une sortie HTML accessible de nos commentaires sur le code des composantes de React. Cette documentation se trouve dans le r√©pertoire `documentation`. En vue de produire la documentation de fa√ßon interactive, vous pouvez ex√©cuter `yarn docs`, qui lancera un serveur Web √† partir duquel vous pouvez visualiser la sortie produite. La sortie sera mise √† jour √† mesure que vous ajusterez les commentaires dans les composantes de React. Afin de produire une sortie HTML statique, veuillez ex√©cuter `yarn docs:build`.

### Contribuer au r√©pertoire de GitHub

T√©l√©chargez GitHub Desktop √† l‚Äôadresse https://desktop.github.com/ (en anglais).
Allez √† https://github.com/veteransaffairscanada/vac-benefits-directory (en anglais), cliquez sur le bouton ¬´ Clone or download ¬ª et s√©lectionnez ouvrir sur le bureau. S√©lectionner l‚Äôemplacement local o√π vous souhaitez enregistrer le projet.

Au moment d‚Äôapporter des modifications, cr√©ez d‚Äôabord une nouvelle branche. Cliquez sur Branch dans le coin sup√©rieur gauche, puis cliquez nouvelle branche.

Apr√®s avoir apport√© vos modifications, validez-les dans GitHub Desktop puis s√©lectionnez ¬´ push changes ¬ª dans le coin sup√©rieur droit. Naviguez jusqu‚Äô√† la page GitHub https://github.com/veteransaffairscanada/vac-benefits-directory (en anglais) et trouvez la branche. Ensuite, cr√©ez une nouvelle demande de tirage pour mieux expliquer les changements que vous avez mis en ≈ìuvre. Par la suite, la demande de tirage sera disponible pour que les r√©viseurs l‚Äôexaminent et s‚Äôassurent que tout est en bon √©tat avant de la fusionner au fichier ma√Ætre.

### Programmation en bin√¥me

#### De quoi s‚Äôagit-il?

La [programmation en bin√¥me ](https://fr.wikipedia.org/wiki/Programmation_en_bin%C3%B4me) est la technique o√π deux d√©veloppeurs travaillent ensemble sur la m√™me t√¢che en utilisant le m√™me poste de travail.

#### Pourquoi et comment l‚Äôutilisons-nous?

- pour int√©grer rapidement des d√©veloppeurs dans le projet ‚Äì le transfert des connaissances se produit rapidement lors du jumelage avec un d√©veloppeur qui conna√Æt la base de code;
- pour travailler sur des fonctionnalit√©s difficiles o√π deux cerveaux constituent un avantage;
- pour le plaisir!

Lorsque deux d√©veloppeurs ne se trouvent pas dans le m√™me emplacement, nous avons effectu√© le jumelage √† l‚Äôaide des moyens suivants :

- Appel t√©l√©phonique pour voix ‚Äì il s‚Äôagit du moyen le plus fiable s‚Äôil y a une connexion r√©seau lente √† une ou plusieurs extr√©mit√©s;
- [Atom](https://atom.io/) (en anglais) avec Teletype pour l‚Äô√©criture du code;
- [Slack](https://slack.com/) (en anglais) pour le partage d‚Äô√©cran, afin que l‚Äôobservateur puisse voir les choses √† l‚Äôext√©rieur de l‚Äô√©diteur de texte comme des tests en cours d‚Äôex√©cution dans le terminal et leur affichage dans le navigateur, entre autres.

#### Comment peut-on effectuer la configuration?

Pour configurer Atom aux fins de la programmation en bin√¥me, effectuez ce qui suit :

1. T√©l√©chargez et installez Atom : https://atom.io/ (en anglais)
2. Ouvrez Atom -> Preferences (Pr√©f√©rences) -> Install (Installer), et recherchez ¬´ Teletype ¬ª
3. Installez Teletype. Une ic√¥ne Teletype (ressemble √† une tour de radio) doit appara√Ætre au bas de votre √©cran.
4. Cliquez sur l‚Äôic√¥ne Teletype et autorisez l‚Äôapplication √† l‚Äôaide de vos justificatifs d‚Äôidentit√© de GitHub.
5. Retournez √† Atom, cliquez sur l‚Äôic√¥ne Teletype √† nouveau, et vous devriez maintenant pouvoir partager votre espace de travail ou vous joindre √† un portail en collant le lien dans l‚Äôespace de travail d‚Äôune autre personne.

### Notifications de d√©ploiement

#### De quoi s‚Äôagit-il?

Les notifications de d√©ploiement sont des messages automatis√©s que nous envoyons √† notre canal interne Slack pour nous informer du d√©ploiement de l‚Äôapplication.

#### Comment fonctionnent-ils?

Au d√©marrage du serveur, l‚Äôapplication enverra une charge utile JSON √† un [webhook Slack entrant](https://api.slack.com/incoming-webhooks "Incoming Webhook"). (en anglais). Le webhook traduit ensuite les renseignements dans un message Slack bien format√© que tous les d√©veloppeurs peuvent voir. Vous pouvez en apprendre davantage sur la fa√ßon dont ils fonctionnent exactement [ici](https://github.com/veteransaffairscanada/vac-benefits-directory/blob/master/utils/deploy_notification.js) (en anglais). L‚Äôimportant est d‚Äô√©tablir une variable environnementale `WEBHOOK_URL` qui est l‚Äôadresse URL de votre Webhook Slack.

#### Quel est l‚Äôobjectif de leur utilisation?

Nous utilisons principalement la notification de d√©ploiement pour veiller √† ce que notre version de production se rende dans le serveur de production. Chaque notification comprend un lien vers la demande de tirage qui a √©t√© fusionn√©e dans `master` ainsi qu‚Äôun horodatage de la fin du d√©marrage du serveur. Cela nous permet de d√©terminer la dur√©e d‚Äôun d√©ploiement en production apr√®s que nous ayons lanc√© une version de production. √Ä l‚Äôheure actuelle, cela prend environ huit minutes de la conception au d√©ploiement.
